import os
import json
import nibabel as nib
import numpy as np
import cupy as cp
import torch

from copy import deepcopy
from cucim.skimage.measure import label, regionprops
from multiprocessing import Pool
from tqdm import tqdm
from totalsegmentator.map_to_binary import class_map

from total_ct.arteries import measure_aorta, measure_binary_diameter

class CTStats:
    """A class to take a list of input CTs generated by CTBatch post-segmentation and perform analysis on their segmentations"""
    total_map = {k: v for k, v in class_map['total'].items() if k < 69}
    def __init__(self, input_cts, num_workers=8):
        """
        :param input_cts: a list of CTScan instances, such as CTBatch.input_cts
        :param num_workers: the number of multiprocessing workers to use. Default = 8
        """
        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        self.ct_list = self._ct_list_check(input_cts)   
        self._load_ct_variables()

        
    def analyze_segmentations(self):
        """method to analyze all of the segmentations from the output of total segmentator and save the results"""
        self.measure_total_stats()
        self.measure_vertebrae_stats()
        self.measure_tissue_stats()
        self.measure_aorta_stats()
        self.write_outputs()
    
    
    def write_outputs(self):
        for ct in self.ct_list:
            out_data = {}
            out_data.update(ct.header_info)
            out_data.update(ct.total_stats)
            out_data.update(ct.vertebrae_stats)
            out_data.update(ct.tissue_stats)
            out_data.update(ct.aorta_stats)
            if os.path.exists(ct.seg_folder):
                with open(f'{ct.seg_folder}/{ct.nii_file_name}_stats.json', 'w') as f:
                    json.dump(out_data, f, indent=4)
                
    
    ### Measurement Functions ###
    def measure_total_stats(self):
        print('Measuring volumes and average HU from "total" segmentation...')
        for ct in self.ct_list:
            ct.total_stats = measure_volume_and_hu(ct, CTStats.total_map, self.device)
        print('Done!\n')
    
    
    def measure_vertebrae_stats(self):
        print("Measuring the vertebrae body midline and average circumference...")
        for ct in tqdm(self.ct_list):
            ct.vertebrae_stats = measure_vertebrae_body_and_diameter(ct, CTStats.total_map)
        print('Done!\n')
            
    def measure_tissue_stats(self):
        print('Measuring adipose tissues and body circumferences...')
        tissue_map = class_map['tissue_types']
        voi = [f'vertebrae_L{i}' for i in [1, 3, 5]]
        for ct in tqdm(self.ct_list):
            ct.tissue_stats = measure_ct_tissue_stats(ct, tissue_map, voi)
        print('Done!\n')
    
    def measure_aorta_stats(self):
        print('Measuring aortic diameter and calcification...')
        for ct in tqdm(self.ct_list):
            ct.aorta_stats = measure_aorta(ct)
            
    
    ## Utility Functions ####
    def _load_ct_variables(self):
        for ct in self.ct_list:
            ct.orig_ct = nib.load(ct.input)
            ct.orig_img = cp.asarray(ct.orig_ct.get_fdata(), dtype=cp.int16)
            
            total_file = f'{ct.seg_folder}/{ct.nii_file_name}_total.nii.gz'
            if not os.path.exists(total_file):
                total_file = f'{ct.seg_folder}/{ct.nii_file_name}_total_fast.nii.gz'
            seg = nib.load(total_file)
            ct.total_seg = cp.asarray(seg.get_fdata(), dtype=cp.int8)
            ct.spacing = seg.header.get_zooms()
            ct.pixel_measurements = self._create_pixel_measurements(ct)
            
    
    @staticmethod
    def _largest_connected_component(arr):
        arr = cp.asarray(arr)
        labeled_arr = label(arr)
        regions = regionprops(labeled_arr)
        lcc = max(regions, key=lambda x: x.area)
        return lcc
    
    @staticmethod
    def _create_pixel_measurements(ct):
        l, w, h = ct.spacing
        pixel_vals = {
            'length': l,
            'width': w,
            'height': h,
            'y_x_spacing': (l, w),
            'voxel_volume': l * w * h,
            'voxel_volume_cm3': l * w * h / 1000,
            'pixel_area': l * w,
            'pixel_area_cm2': l * w / 100,
            'pixel_spacing': (l + w) / 2,
            'pixel_spacing_cm': ((l + w) / 2) / 10
        }
        return pixel_vals
     
    @staticmethod
    def _ct_list_check(input_cts):
        """a method to check if the input_cts are usable, and if their appropriate output segmentations exist
        :param input_cts: the input to the class initialization
        :return: the list of CTScan instances to analyze
        """
        analyzable_cts = []
        for input_ct in input_cts:
            if input_ct.usable:
                for i, nii in enumerate(input_ct.input):
                    ct = deepcopy(input_ct)
                    nifti_name = ct.nii_file_name[i]
                    output_dir = f'{ct.output_dir}/{nifti_name}_segs'
                    if os.path.exists(output_dir):
                        seg_exists = []
                        for task in ['total', 'tissue_types', 'vertebrae_body', 'body']:
                            seg_completed = os.path.exists(f'{output_dir}/{nifti_name}_{task}.nii.gz')
                            if seg_completed:
                                seg_exists.append(True)
                            elif task == 'total' and not seg_completed:
                                if os.path.exists(f'{output_dir}/{nifti_name}_{task}_fast.nii.gz'):
                                    seg_exists.append(True)
                                else:
                                    seg_exists.append(False)
                            else:
                                seg_exists.append(False)
                        if all(seg_exists):
                            ct.input = nii
                            ct.nii_file_name = nifti_name
                            ct.seg_folder = output_dir
                            analyzable_cts.append(ct)
                    else:
                        print(f'{output_dir} does not exist!')
        return analyzable_cts


## Independent measurement functions, to be used inside the class (makes it easier to implement multiprocessing if desired)
def measure_volume_and_hu(ct, task_map: dict, device: str) -> dict:
    """Function to measure the volume and average HU of each segmentation with respect to the original image
    :param ct: the CTScan instance
    :param task_map: the task dictionary that we are mapping results to
    """
    task_stats = {}
    original = ct.orig_img
    segmentation = ct.total_seg
    vox_vol = ct.pixel_measurements['voxel_volume_cm3']
    for k, mask_name in tqdm(task_map.items()):
        data = segmentation == k
        task_stats[f'{mask_name}_volume_cm3'] = round(float(data.sum() * vox_vol), 2)
        roi_mask = (data > 0)
        task_stats[f'{mask_name}_average_HU'] = round(float(cp.average(original, weights=roi_mask)), 2) if roi_mask.sum() > 0 else 0.0
        del data
    del original
    del segmentation
    if device == 'cuda':
        torch.cuda.empty_cache()
    return task_stats


def measure_vertebrae_body_and_diameter(ct, class_map):
    cm_spacing = ct.pixel_measurements['pixel_spacing_cm']
    vert_bodies = cp.asarray(
        nib.load(f'{ct.seg_folder}/{ct.nii_file_name}_vertebrae_body.nii.gz').get_fdata(),
        dtype=cp.int8
    )
    verts = cp.where(vert_bodies == 1, ct.total_seg, 0)
    del vert_bodies
    vert_range = range(26, 51) # This is the range of indicies in the class map which correspond to vertebrae
    vert_vals = {}
    # Loop through the indices and measure the midline and diameter for each body
    for i in vert_range:
        name = class_map.get(i)
        arr = verts == i
        if arr.sum() != 0:
            z_indices = cp.where(arr)[-1]
            z_slices, frequencies = cp.unique(z_indices, return_counts=True)
            weighted_midline = int(cp.sum(z_slices * frequencies) / cp.sum(frequencies))
            average_axis, major_axis, minor_axis = measure_binary_diameter((arr[:, :, weighted_midline]), ct.pixel_measurements['y_x_spacing'])
            vert_vals[name] = {'midline': weighted_midline, 'average_axis_mm': average_axis, 'major_axis_diameter_mm': major_axis, 'minor_axis_diameter_mm': minor_axis}
        else:
            vert_vals[name] = {'midline': None, 'average_axis_mm': None, 'major_axis_diameter_mm': None, 'minor_axis_diameter_mm': None}
    return vert_vals


def measure_ct_tissue_stats(ct, tissue_map, voi):
    verts = {v.replace('vertebrae_', ''): ct.vertebrae_stats[v]['midline'] for v in voi if ct.vertebrae_stats[v]['midline'] is not None}
    tissue_stats = {}
    if len(verts) == 0:
        print('L1-L5 vertebrae are not in this CT image.')
        return tissue_stats

    if len(verts) == 1:
        start = 0
    else:
        min_vert = min(verts, key=verts.get)
        start = verts[min_vert]
    max_vert = max(verts, key=verts.get)
    end = verts[max_vert] + 1
    # Get the necessary pixel_measurements
    vox_vol = ct.pixel_measurements['voxel_volume_cm3']
    pix_area = ct.pixel_measurements['pixel_area_cm2']
    pixel_spacing = ct.pixel_measurements['pixel_spacing_cm']
    # Separate the body from the segmentation
    body = cp.asarray(
        nib.load(f'{ct.seg_folder}/{ct.nii_file_name}_body.nii.gz').get_fdata(),
        dtype=cp.int8
    )
    body = body == 1
    # Load in the tissues
    tissues = cp.asarray(
        nib.load(f'{ct.seg_folder}/{ct.nii_file_name}_tissue_types.nii.gz').get_fdata(),
        dtype=cp.int8
    )
    body_abdominal = body[:, :, start:end]
    tissue_stats['total_body_volume'] = round(float(body.sum() * vox_vol), 2)
    tissue_stats['total_abdominal_body_volume'] = round(float(body_abdominal.sum() * vox_vol), 2)
    for idx, tissue in tissue_map.items():
        tissue_msk = tissues == idx
        tissue_stats[f'total_{tissue}_cm3'] = round(float((tissue_msk.sum() * vox_vol)), 2)
        tissue_stats[f'total_abdominal_{tissue}_cm3'] = round(float((tissue_msk[:, :, start:end].sum() * vox_vol)), 2)
    for vert, midline in verts.items():
        vert_body = CTStats._largest_connected_component(body[:, :, midline])
        tissue_stats[f'{vert}_body_area_cm2'] = round(float((vert_body.area * pix_area)), 2)
        tissue_stats[f'{vert}_body_circ_cm'] = round(float(vert_body.perimeter * pixel_spacing), 2)
        tissue_stats[f'{vert}_body_circ_in'] = round(tissue_stats[f'{vert}_body_circ_cm'] / 2.54, 2)
        for idx, tissue in tissue_map.items():
            tissue_msk = tissues == idx
            vert_tissue = tissue_msk[:, :, midline]
            tissue_stats[f'{vert}_{tissue}_cm2'] = round(float((vert_tissue.sum() * pix_area)), 2)
    return tissue_stats


